To simulate the Memory Manager, we wanted to encapsulate a set of operations and variables the Memory Manager will use during the simulation. We decided to use a class to represent the Memory Manager, with the primary data structure being a C++ map. The private functions and variables are all used to drive the simulation during execution. The keys of the map represent a frame and the values will contain the Process in that frame. If there is no process in a frame, a process with PID of -1 will be there to signify the frame is available. The Memory Manager object in main.cpp will read an input file containing a list of processes used for the simulation. After doing so, the Memory Manager object will run a function called simulate and the simulation will begin. Simulation will begin by initializing the map to all empty frames and setting the clock to zero. Then it enters a while loop which will continue until simulation is done. Each loop iteration will begin checking for ready processes, marking them, and then pushing them to a queue. After so, the simulation will count the number of free frames available and allocate a process if it can fit in the number of free frames. Then it will check for finished processes, deallocate them, and then try to allocate another process since after deallocation, free frames will be available. At each event of either processes arriving or allocating/deallocating, the clock and the details of the event will be printed.  At the end of each cycle, the simulation will check if all processes have been terminated and if so, end the simulation. 
